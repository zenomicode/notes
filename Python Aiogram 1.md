## Доступ к GitHub по SSH

Чтобы GitHub мог нас аутентифицировать по SSH, нам и надо создать пару ключей. Делается это так. Открываем терминал на своем локальном компьютере и выполняем команду:

```no-highlight
ssh-keygen
```

Получим сообщение вида:

```no-highlight
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/mikhail/.ssh/id_rsa):
```

То есть нам предлагается ввести название файла, в котором будет храниться пара ключей. По умолчанию, предлагается название `id_rsa` - согласимся с предложением, нажав Enter. Будет создана директория `.ssh`, а также предложено ввести дополнительно **passphrase** для дополнительной защиты самой пары ключей.

```no-highlight
Created directory '/Users/mikhail/.ssh'.
Enter passphrase (empty for no passphrase): 
```

Можно ничего не вводить, а просто два раза нажать Enter.

```no-highlight
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /Users/mikhail/.ssh/id_rsa.
Your public key has been saved in /Users/mikhail/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:+f49gd7YeKew0IE2TFGptjMafiXMY1OIHD/m2S5FaSQ mikhail@Air-Mihail
The key's randomart image is:
+---[RSA 3072]----+
|          ....   |
|        . E.o    |
|       . +.= .   |
|        o+B.=    |
|        S*=O..   |
|        .o&o=..  |
|       . +o@o= . |
|        o.o.=+= .|
|         ..oo.o+ |
+----[SHA256]-----+
```

Была сгенерирована пара ключей. Закрытый хранится в файле `id_rsa`, а открытый в файле `id_rsa.pub`.

```no-highlight
cat <путь_к_файлу_с_публичным_ключом>
```

Далее, идем на GitHub в свой профиль и переходим в настройки (**Settings**).

![](https://ucarecdn.com/49d10e3c-8981-472b-b625-59c278cc1a56/-/preview/-/enhance/88/)

И на открывшейся странице нужно найти пункт **SSH и GPG keys**. Нажимаем на него.

![](https://ucarecdn.com/717459b1-481a-41a6-8ee7-fbf7367e3bf1/-/preview/-/enhance/85/)

Далее надо нажать на кнопку **New SSH key**, дать название ключу и в специальное поле **key** вставить содержимое буфера обмена.

![](https://ucarecdn.com/f9a5c2c2-220c-458b-a4f6-66279e30e166/-/preview/-/enhance/81/)

![](https://ucarecdn.com/60d962ce-4f67-4a8f-a260-69e273278293/-/preview/-/enhance/75/)

Поле **Title** заполняется только для того, чтобы вы сами могли различать какие ключи с каким компьютером используются. Можете назвать как угодно. **Key type** оставляем в позиции **Authentication Key**, потому что пока нам нужен именно доступ к репозиториям (**Signing Key** нужен для защиты ваших коммитов, поэтому пока его заполнять не будем). Нажимаем на **Add SSH key**. GitHub попросит ввести пароль от аккаунта.

Вводим пароль и теперь в списке SSH ключей есть новый ключ.

## Аннотация типов
1. [Типизированный Python](https://youtu.be/dKxiHlZvULQ) - почти трехчасовой YouTube-ролик с подробным объяснением и множеством примеров.
2. [Книга](https://to.digital/typed-python/) по мотивам ролика для тех, кому удобнее читать, чем смотреть.

Синтаксис аннотаций для переменных следующий:

```no-highlight
<имя_переменной>: <тип_переменной> = <значение_переменной>
```

Или без значения переменной:

```no-highlight
<имя_переменной>: <тип_переменной>:
```

Синтаксис аннотаций для функций (методов):

```python
def <имя_функции>(<arg_1>: <тип>, <arg_2>: <тип> = <значение>) -> <тип_результата>:
    <тело функции>
```

Причем, если нужно указать больше одного типа, например, функция может принимать и целые, и вещественные числа, используют символ `|`, обозначающий "или".

**Пример 1.** Функция `some_function` принимает либо целое, либо вещественное число, а возвращает `None`.

```python
def some_function(number: int | float) -> None:
    pass
```

**Пример 2.** Функция `another_some_function` принимает либо целое, либо вещественное, либо комплексное число со значением по умолчанию, равным `0`. Возращает `None`.

```python
def another_some_function(number: int | float | complex = 0) -> None:
    pass
```

Коллекции, типа, `list`, `dict`, `tuple`, `set` и т.п., также в квадратных скобках позволяют указывать типы, входящих в них объектов.

**Пример 3.** 

```python
lst_1: list[int]                # Все элементы списка lst_1 типа int
tpl_2: tuple[bool]              # Все элементы кортежа tpl_2 типа bool
tpl_3: tuple[int, bool, float]  # Кортеж tpl_3 состоит из трех элементов
                                # Первый типа int, второй типа bool, а третий типа float
set_4: set[int | float]         # Элементы множества set_4 либо int, либо float типов
```

**Пример 4.** Функция `get_tuple` принимает список, в котором могут быть вещественные числа и/или булевы значения, а возвращает кортеж целых чисел.

```python
def get_tuple(lst: list[float | bool]) -> tuple[int]:
    return tuple(int(num) for num in lst)
```

**Пример 5.** Функция `do_something` принимает словарь, ключами в котором являются целые числа, а значениями либо строки, либо булевы значения. Возвращает `None`.

```python
def do_something(arg: dict[int, str | bool]) -> None:
    pass
```

## Типы из модуля typing

Помимо стандартных встроенных типов, для аннотаций можно использовать типы из модуля `typing`. Там много всего - можно подробно изучить в [документации к модулю](https://docs.python.org/3/library/typing.html). Разберем некоторые интересные:

- Any
- Optional
- Union
- Literal

### Тип Any (использовать, по-возможности, никогда :) )

Бывает так, что указать тип не представляется возможным, потому что точно неизвестно какие данные придут. Тогда используют тип `Any` из модуля `typing`. 

```python
from typing import Any


def func(arg: Any) -> None:
    pass
```

Использовать часто этот тип не рекомендуется, потому что единственное, что он нам говорит о функции, что она может принимать данные любых типов. В принципе, если мы не аннотируем ее, то тоже будем думать, что она может принимать данные любых типов. Не очень информативно. Лучше все-таки разобраться, что там за данные приходят и добавить более осмысленную аннотацию.

### Тип Optional

Данный тип подразумевает, что данные могут быть либо какого-то конкретного типа, либо `None`.

```python
from typing import Optional


var_1: Optional[int]
```

### Тип Union

Как понятно из названия типа - это объединение разных типов. По сути - это другой способ записать, что переменная может быть либо одного, либо другого типа, как мы это делали с помощью символа `|`.

Код:

```python
from typing import Union


var_1: Union[int, float]
var_2: Union[list, tuple, set]
```

эквивалентен коду:

```python
var_1: int | float
var_2: list | tuple | set
```

### Тип Literal

Используется тогда, когда ожидаются очень конкретные значения (`Literal` - от английского "literally", то есть "буквально"). Например, в качестве ключей словаря могут быть только строки `'name'`, `'second_name'` и `'username'`. Тогда можно записать:

```python
from typing import Literal


user : dict[Literal['name'] | Literal['second_name'] | Literal['username'], str]
```

Во-первых, IDE сможет подсказать какие ключи в таком словаре доступны, а во-вторых, анализатор кода будет ругаться, если мы попробуем в такой словарь поместить какой-то другой ключ.

![](https://ucarecdn.com/380fc7b4-024f-413a-b668-01dd3a21e65d/-/preview/-/enhance/75/)

![](https://ucarecdn.com/d8af43bd-fcc3-4dcf-b39e-7245b4b86ad8/-/preview/-/enhance/75/)

Помимо обозначенных типов, в модуле `typing` их еще много разных, буквально, на все случаи жизни. А если и их вам не хватает - никто не мешает создавать свои классы. Чем мы и займемся в следующем шаге.

## Примеры API

- [GitHub-репозиторий](https://github.com/public-apis/public-apis) с большим количеством публичных API
- [Статья на Хабре](https://habr.com/ru/company/macloud/blog/562700/) со списком "интересных (и забавных)" API

