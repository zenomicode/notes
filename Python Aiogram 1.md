
## Примеры API

- [GitHub-репозиторий](https://github.com/public-apis/public-apis) с большим количеством публичных API
- [Статья на Хабре](https://habr.com/ru/company/macloud/blog/562700/) со списком "интересных (и забавных)" API

## Библиотека logging

У данной библиотеки довольно хорошая [документация](https://docs.python.org/3/library/logging.html), в которую вы всегда можете углубиться для лучшего понимания настройки и работы с инструментом.

А самая простая программа с использованием библиотеки может выглядеть так:

```python
import logging

logging.error('Это лог какой-то ошибки')
```

В результате выполнения которой, в консоли можно получить следующий вывод:

```no-highlight
ERROR:root:Это лог какой-то ошибки
```

В данном сообщении `ERROR` - это уровень, на котором был создан лог, `root` - это имя логгера, а так как мы еще не создавали свои логгеры, то в нашем случае, это `root`, то есть корневой логгер, ну, и сам текст лога, который мы передали - `Это лог какой-то ошибки`.

То есть, когда нам нужно во время работы программы вывести в консоль и/или в файл какую-то информацию о работе программы, мы просто в нужном месте кода вставляем конструкцию вида:

```python
logging.<метод_отвечающий_за_уровень_логирования>('<сообщение>')
```

Основными ключевыми понятиями в библиотеке `logging` являются:

- **Логгеры**. Предоставляют интерфейс пользователю для создания логов в коде.
- **Уровни логирования**. Определяют степень серьезности информации, выводимой в логах.
- **Хэндлеры**. Определяют место вывода логов (например, консоль или файл).
- **Форматтеры.** Определяют то, как логи будут выглядеть.
- **Фильтры.** Позволяют гибко настраивать то, какие логи выводить.

## Уровни логирования

Основных уровней логирования в библиотеке `logging` пять: от самого низкого `DEBUG` до самого высокого `CRITICAL`:

1. `DEBUG` (10)
2. `INFO` (20)
3. `WARNING` (30)
4. `ERROR` (40)
5. `CRITICAL` (50)

Здесь 10, 20, ... , 50 - это просто числовой способ записи этих же уровней, чтобы можно было легко сравнивать уровни между собой и понимать какой из них выше, а какой ниже. Собственно, если посмотреть на вывод в консоль результата выполнения такого кода:

```python
import logging

print(logging.DEBUG)
print(logging.INFO)
print(logging.WARNING)
print(logging.ERROR)
print(logging.CRITICAL)
```

Как раз можно увидеть числовые значения:

```no-highlight
10
20
30
40
50
```

Строго говоря, есть еще и нулевой уровень `NOTSET`, но он ведет себя не так, как остальные. Когда у логгера установлен уровень `NOTSET` - берется уровень его родительского логгера, если и там `NOTSET`, то идет обращение к уровню его родителя и так до корневого логгера. Если и в корневом логгере тоже `NOTSET`, то логируются события всех уровней.

### DEBUG

Используется для отладки. Это, наверное, самый близкий к принтам уровень логирования по смыслу. Чаще всего нам не нужна в продакшне отладочная информация, она нужна только разработчику для какой-то диагностики приложения. Так же, как отладочные принты нам становятся не нужны после того, как мы добились желаемого поведения от настраиваемого участка кода, так же и логирование уровня `DEBUG` обычно игнорируется во время штатной работы приложения.

### INFO

Этот уровень используется для того, чтобы сообщить разработчику, что все идет как запланировано. Также редко нужен вне процесса отладки и тоже похож по смыслу на логирование принтами.

### WARNING

Данный уровень предназначен для логирования событий, которые могут привести к проблемам в будущем, но пока не влияют на работу приложения. Типичный пример логов такого уровня - это сообщение о заканчивающемся месте на диске. Пока хватает и все работает, но если с этим что-то не сделать, то можно столкнуться с нежелательными последствиями.

### ERROR

Уровень `ERROR` отвечает за ошибки в работе приложения. Что-то идет не так. Приложение еще не падает, но уже явно требует обратить на себя внимание.

### CRITICAL

Уровень для серьезных ошибок, после которых, чаще всего, приложение уже не сможет работать дальше.

**Пример 1.** Настраиваем уровень `DEBUG`, как минимальный уровень, с которого требуется вывод логов.

```python
import logging

logging.basicConfig(level=logging.DEBUG)

logging.debug('Это лог уровня DEBUG')
logging.info('Это лог уровня INFO')
logging.warning('Это лог уровня WARNING')
logging.error('Это лог уровня ERROR')
logging.critical('Это лог уровня CRITICAL')
```

И, соответственно, теперь получаем в консоли сообщения всех уровней:

```no-highlight
DEBUG:root:Это лог уровня DEBUG
INFO:root:Это лог уровня INFO
WARNING:root:Это лог уровня WARNING
ERROR:root:Это лог уровня ERROR
CRITICAL:root:Это лог уровня CRITICAL
```

**Пример 2.** Настраиваем логирование на вывод сообщений только уровня `CRITICAL`.

```python
import logging

logging.basicConfig(level=logging.CRITICAL)

logging.debug('Это лог уровня DEBUG')
logging.info('Это лог уровня INFO')
logging.warning('Это лог уровня WARNING')
logging.error('Это лог уровня ERROR')
logging.critical('Это лог уровня CRITICAL')
```

И получаем соответствующий вывод:

```no-highlight
CRITICAL:root:Это лог уровня CRITICAL
```

## Логгеры

Центральными объектами в рамках логирования считаются логгеры - экземпляры класса `Logger`. Именно через логгеры удобно создавать логи и управлять их выводом. Логгеров в проекте может быть сколько угодно, но обычно по одному в каждом модуле проекта, а также корневой логгер (`root`). Создаются логгеры просто - с помощью вызова функции `getLogger()`. При этом, если не передать в функцию никаких аргументов, то будет получена ссылка на корневой:

```python
import logging

logger = logging.getLogger()

print(logger)
```

Результат работы этого кода:

```bash
<RootLogger root (WARNING)>
```

То есть, переменная `logger` ссылается на экземпляр класса `RootLogger` с именем `root` и уровнем логирования `WARNING`. Но обычно нам не нужны свои собственные ссылки на корневой логгер. Мы хотим создавать логгеры со своими именами и заданными свойствами, поэтому в функцию `getLogger` передают единственный аргумент, который она может принять - `name`. Имя логгера может быть любым (любой строкой, если быть точнее), но согласно конвенции (неформальной договоренности разработчиков) принято называть логгеры по имени модуля, в котором они создаются, а за имя модуля, как вы знаете, отвечает магическая переменная `__name__`:

```python
import logging

logger = logging.getLogger(__name__)

print(logger)
```

Результат работы кода:

```bash
<Logger __main__ (WARNING)>
```

Как видно логгер получил имя по имени модуля, в котором он инициализирован. Так как в данном примере код выполняется в единственном модуле, который автоматически получает имя `__main__`, то и логгер теперь называется точно также. Такое соглашение принято для того, чтобы легче было искать где именно находится нужный логгер в проекте.

Давайте теперь посмотрим, что из себя представляет только что созданный объект класса `Logger`. Для этого передадим наш логгер в функцию `dir`:

```python
import logging

logger = logging.getLogger(__name__)

print(dir(logger))
```

Результат:

```bash
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_cache', '_log', 'addFilter', 'addHandler', 'callHandlers', 'critical', 'debug', 'disabled', 'error', 'exception', 'fatal', 'filter', 'filters', 'findCaller', 'getChild', 'getEffectiveLevel', 'handle', 'handlers', 'hasHandlers', 'info', 'isEnabledFor', 'level', 'log', 'makeRecord', 'manager', 'name', 'parent', 'propagate', 'removeFilter', 'removeHandler', 'root', 'setLevel', 'warn', 'warning']
```

Атрибутов у данного объекта довольно много. Некоторые могут быть понятны из их названия, например `name`, отвечающий за имя логгера, или `parent`, отвечающий за родителя данного логгера, или `level`, отвечающий за уровень логгера. Но также много и не совсем очевидных атрибутов, типа, `isEnabledFor`, `manager` или `propagate`. Все атрибуты знать не надо, потому что всегда можно подсмотреть за что они отвечают в документации, ну, и некоторые мы рассмотрим в курсе. Пока моя задача дать вам понять, что объекты класса `Logger` имеют довольно широкий функционал, как раз и позволяющий настраивать систему логирования вашего проекта очень гибко.

Логгеры выстраиваются в иерархию. У каждого логгера, кроме `root`, есть предки. Продемонстрирую это таким примером:

```python
import logging

logger = logging.getLogger()

print(logger.parent)

logger = logging.getLogger(__name__)

print(logger.parent)
```

Результат:

```bash
None
<RootLogger root (WARNING)>
```

То есть, для `root`-логгера в атрибуте `parent` записано значение `None`, а для логгера `__main__` предком является как раз `root`-логгер. Иерархию логгеров можно выстраивать с помощью точечной нотации в имени:

```python
import logging

logger_1 = logging.getLogger('one.two')

print(logger_1.parent)

logger_2 = logging.getLogger('one.two.three')

print(logger_2.parent)
```

Результат:

```bash
<RootLogger root (WARNING)>
<Logger one.two (WARNING)>
```

То есть для логгера с именем `one.two.three` предком является логгер `one.two`, а для логгера `one.two` - логгер с именем `root`. Понимание того, как работает такая иерархия также позволяет гибко настраивать логирование, но сильно в это закапываться не будем. Для наших задач достаточно понимать, что:

1. Логгеров с одинаковым именем не может быть больше одного
2. Логгеры следует называть по имени модуля, в котором они создаются, передавая в функцию `getLogger` аргумент `__name__`.
3. Корневым логгером является `root`-логгер
4. У каждого логгера, кроме `root`, есть предки
5. Если в каком-то логгере не заданы его настройки - берутся настройки его предка, вплоть до `root`-логгера.

Чтобы добавить вывод лога в каком-либо месте модуля, нужно обратиться к одному из методов логгера (`debug`, `info`, `warning` и так далее):

```python
import logging

logger = logging.getLogger(__name__)

logger.warning('Предупреждение!')
logger.debug('Отладочная информация')
```

Результат:

```bash
Предупреждение!
```

Думаю, исходя из предыдущего шага про уровни логирования, несложно догадаться почему только одно сообщение выведено. Уровень всех логгеров по умолчанию `NOTSET`, а значит берется уровень их предков, в нашем случае это `root`-логгер, уровень которого, без дополнительных специальных настроек, устанавливается в `WARNING`, потому лог уровня `DEBUG` проигнорирован. Причем, исправить это, явно задав уровень логгера как, например, `DEBUG`, не получится:

```python
import logging

logger = logging.getLogger(__name__)
logger.level = logging.DEBUG

logger.warning('Предупреждение!')
logger.debug('Отладочная информация')
```

Результат будет таким же, как предыдущий:

```bash
Предупреждение!
```

Потому что, хоть логгеру мы и установили уровень `DEBUG`, мы не задавали явно базовую конфигурацию логирования, а по умолчанию она, как вы помните, как раз `WARNING`.

Также вы, возможно, отметили, что вывод лога содержит только само сообщение и больше никакой другой информации. Это можно легко исправить, добавив форматтер для логгера, о чем поговорим в следующем шаге.

**Примечание 1.** Логгер с определенным именем в проекте может быть только один, поэтому, если вы в нескольких модулях создадите логгеры с одинаковым именем, то они будут ссылаться на один и тот же логгер.

**Примечание 2.** Во время создания записи лога внутри логгера создается экземпляр класса `LogRecord`, который хранит в себе всю необходимую информацию, связанную с вызовом лога (время, имя модуля, где был вызван лог, уровень лога и т.п.)

