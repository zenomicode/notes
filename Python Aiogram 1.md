
## Примеры API

- [GitHub-репозиторий](https://github.com/public-apis/public-apis) с большим количеством публичных API
- [Статья на Хабре](https://habr.com/ru/company/macloud/blog/562700/) со списком "интересных (и забавных)" API

## Библиотека logging

У данной библиотеки довольно хорошая [документация](https://docs.python.org/3/library/logging.html), в которую вы всегда можете углубиться для лучшего понимания настройки и работы с инструментом.

А самая простая программа с использованием библиотеки может выглядеть так:

```python
import logging

logging.error('Это лог какой-то ошибки')
```

В результате выполнения которой, в консоли можно получить следующий вывод:

```no-highlight
ERROR:root:Это лог какой-то ошибки
```

В данном сообщении `ERROR` - это уровень, на котором был создан лог, `root` - это имя логгера, а так как мы еще не создавали свои логгеры, то в нашем случае, это `root`, то есть корневой логгер, ну, и сам текст лога, который мы передали - `Это лог какой-то ошибки`.

То есть, когда нам нужно во время работы программы вывести в консоль и/или в файл какую-то информацию о работе программы, мы просто в нужном месте кода вставляем конструкцию вида:

```python
logging.<метод_отвечающий_за_уровень_логирования>('<сообщение>')
```

Основными ключевыми понятиями в библиотеке `logging` являются:

- **Логгеры**. Предоставляют интерфейс пользователю для создания логов в коде.
- **Уровни логирования**. Определяют степень серьезности информации, выводимой в логах.
- **Хэндлеры**. Определяют место вывода логов (например, консоль или файл).
- **Форматтеры.** Определяют то, как логи будут выглядеть.
- **Фильтры.** Позволяют гибко настраивать то, какие логи выводить.

## Уровни логирования

Основных уровней логирования в библиотеке `logging` пять: от самого низкого `DEBUG` до самого высокого `CRITICAL`:

1. `DEBUG` (10)
2. `INFO` (20)
3. `WARNING` (30)
4. `ERROR` (40)
5. `CRITICAL` (50)

Здесь 10, 20, ... , 50 - это просто числовой способ записи этих же уровней, чтобы можно было легко сравнивать уровни между собой и понимать какой из них выше, а какой ниже. Собственно, если посмотреть на вывод в консоль результата выполнения такого кода:

```python
import logging

print(logging.DEBUG)
print(logging.INFO)
print(logging.WARNING)
print(logging.ERROR)
print(logging.CRITICAL)
```

Как раз можно увидеть числовые значения:

```no-highlight
10
20
30
40
50
```

Строго говоря, есть еще и нулевой уровень `NOTSET`, но он ведет себя не так, как остальные. Когда у логгера установлен уровень `NOTSET` - берется уровень его родительского логгера, если и там `NOTSET`, то идет обращение к уровню его родителя и так до корневого логгера. Если и в корневом логгере тоже `NOTSET`, то логируются события всех уровней.

### DEBUG

Используется для отладки. Это, наверное, самый близкий к принтам уровень логирования по смыслу. Чаще всего нам не нужна в продакшне отладочная информация, она нужна только разработчику для какой-то диагностики приложения. Так же, как отладочные принты нам становятся не нужны после того, как мы добились желаемого поведения от настраиваемого участка кода, так же и логирование уровня `DEBUG` обычно игнорируется во время штатной работы приложения.

### INFO

Этот уровень используется для того, чтобы сообщить разработчику, что все идет как запланировано. Также редко нужен вне процесса отладки и тоже похож по смыслу на логирование принтами.

### WARNING

Данный уровень предназначен для логирования событий, которые могут привести к проблемам в будущем, но пока не влияют на работу приложения. Типичный пример логов такого уровня - это сообщение о заканчивающемся месте на диске. Пока хватает и все работает, но если с этим что-то не сделать, то можно столкнуться с нежелательными последствиями.

### ERROR

Уровень `ERROR` отвечает за ошибки в работе приложения. Что-то идет не так. Приложение еще не падает, но уже явно требует обратить на себя внимание.

### CRITICAL

Уровень для серьезных ошибок, после которых, чаще всего, приложение уже не сможет работать дальше.

**Пример 1.** Настраиваем уровень `DEBUG`, как минимальный уровень, с которого требуется вывод логов.

```python
import logging

logging.basicConfig(level=logging.DEBUG)

logging.debug('Это лог уровня DEBUG')
logging.info('Это лог уровня INFO')
logging.warning('Это лог уровня WARNING')
logging.error('Это лог уровня ERROR')
logging.critical('Это лог уровня CRITICAL')
```

И, соответственно, теперь получаем в консоли сообщения всех уровней:

```no-highlight
DEBUG:root:Это лог уровня DEBUG
INFO:root:Это лог уровня INFO
WARNING:root:Это лог уровня WARNING
ERROR:root:Это лог уровня ERROR
CRITICAL:root:Это лог уровня CRITICAL
```

**Пример 2.** Настраиваем логирование на вывод сообщений только уровня `CRITICAL`.

```python
import logging

logging.basicConfig(level=logging.CRITICAL)

logging.debug('Это лог уровня DEBUG')
logging.info('Это лог уровня INFO')
logging.warning('Это лог уровня WARNING')
logging.error('Это лог уровня ERROR')
logging.critical('Это лог уровня CRITICAL')
```

И получаем соответствующий вывод:

```no-highlight
CRITICAL:root:Это лог уровня CRITICAL
```

## Логгеры

Центральными объектами в рамках логирования считаются логгеры - экземпляры класса `Logger`. Именно через логгеры удобно создавать логи и управлять их выводом. Логгеров в проекте может быть сколько угодно, но обычно по одному в каждом модуле проекта, а также корневой логгер (`root`). Создаются логгеры просто - с помощью вызова функции `getLogger()`. При этом, если не передать в функцию никаких аргументов, то будет получена ссылка на корневой:

```python
import logging

logger = logging.getLogger()

print(logger)
```

Результат работы этого кода:

```bash
<RootLogger root (WARNING)>
```

То есть, переменная `logger` ссылается на экземпляр класса `RootLogger` с именем `root` и уровнем логирования `WARNING`. Но обычно нам не нужны свои собственные ссылки на корневой логгер. Мы хотим создавать логгеры со своими именами и заданными свойствами, поэтому в функцию `getLogger` передают единственный аргумент, который она может принять - `name`. Имя логгера может быть любым (любой строкой, если быть точнее), но согласно конвенции (неформальной договоренности разработчиков) принято называть логгеры по имени модуля, в котором они создаются, а за имя модуля, как вы знаете, отвечает магическая переменная `__name__`:

```python
import logging

logger = logging.getLogger(__name__)

print(logger)
```

Результат работы кода:

```bash
<Logger __main__ (WARNING)>
```

Как видно логгер получил имя по имени модуля, в котором он инициализирован. Так как в данном примере код выполняется в единственном модуле, который автоматически получает имя `__main__`, то и логгер теперь называется точно также. Такое соглашение принято для того, чтобы легче было искать где именно находится нужный логгер в проекте.

Давайте теперь посмотрим, что из себя представляет только что созданный объект класса `Logger`. Для этого передадим наш логгер в функцию `dir`:

```python
import logging

logger = logging.getLogger(__name__)

print(dir(logger))
```

Результат:

```bash
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_cache', '_log', 'addFilter', 'addHandler', 'callHandlers', 'critical', 'debug', 'disabled', 'error', 'exception', 'fatal', 'filter', 'filters', 'findCaller', 'getChild', 'getEffectiveLevel', 'handle', 'handlers', 'hasHandlers', 'info', 'isEnabledFor', 'level', 'log', 'makeRecord', 'manager', 'name', 'parent', 'propagate', 'removeFilter', 'removeHandler', 'root', 'setLevel', 'warn', 'warning']
```

Атрибутов у данного объекта довольно много. Некоторые могут быть понятны из их названия, например `name`, отвечающий за имя логгера, или `parent`, отвечающий за родителя данного логгера, или `level`, отвечающий за уровень логгера. Но также много и не совсем очевидных атрибутов, типа, `isEnabledFor`, `manager` или `propagate`. Все атрибуты знать не надо, потому что всегда можно подсмотреть за что они отвечают в документации, ну, и некоторые мы рассмотрим в курсе. Пока моя задача дать вам понять, что объекты класса `Logger` имеют довольно широкий функционал, как раз и позволяющий настраивать систему логирования вашего проекта очень гибко.

Логгеры выстраиваются в иерархию. У каждого логгера, кроме `root`, есть предки. Продемонстрирую это таким примером:

```python
import logging

logger = logging.getLogger()

print(logger.parent)

logger = logging.getLogger(__name__)

print(logger.parent)
```

Результат:

```bash
None
<RootLogger root (WARNING)>
```

То есть, для `root`-логгера в атрибуте `parent` записано значение `None`, а для логгера `__main__` предком является как раз `root`-логгер. Иерархию логгеров можно выстраивать с помощью точечной нотации в имени:

```python
import logging

logger_1 = logging.getLogger('one.two')

print(logger_1.parent)

logger_2 = logging.getLogger('one.two.three')

print(logger_2.parent)
```

Результат:

```bash
<RootLogger root (WARNING)>
<Logger one.two (WARNING)>
```

То есть для логгера с именем `one.two.three` предком является логгер `one.two`, а для логгера `one.two` - логгер с именем `root`. Понимание того, как работает такая иерархия также позволяет гибко настраивать логирование, но сильно в это закапываться не будем. Для наших задач достаточно понимать, что:

1. Логгеров с одинаковым именем не может быть больше одного
2. Логгеры следует называть по имени модуля, в котором они создаются, передавая в функцию `getLogger` аргумент `__name__`.
3. Корневым логгером является `root`-логгер
4. У каждого логгера, кроме `root`, есть предки
5. Если в каком-то логгере не заданы его настройки - берутся настройки его предка, вплоть до `root`-логгера.

Чтобы добавить вывод лога в каком-либо месте модуля, нужно обратиться к одному из методов логгера (`debug`, `info`, `warning` и так далее):

```python
import logging

logger = logging.getLogger(__name__)

logger.warning('Предупреждение!')
logger.debug('Отладочная информация')
```

Результат:

```bash
Предупреждение!
```

Думаю, исходя из предыдущего шага про уровни логирования, несложно догадаться почему только одно сообщение выведено. Уровень всех логгеров по умолчанию `NOTSET`, а значит берется уровень их предков, в нашем случае это `root`-логгер, уровень которого, без дополнительных специальных настроек, устанавливается в `WARNING`, потому лог уровня `DEBUG` проигнорирован. Причем, исправить это, явно задав уровень логгера как, например, `DEBUG`, не получится:

```python
import logging

logger = logging.getLogger(__name__)
logger.level = logging.DEBUG

logger.warning('Предупреждение!')
logger.debug('Отладочная информация')
```

Результат будет таким же, как предыдущий:

```bash
Предупреждение!
```

Потому что, хоть логгеру мы и установили уровень `DEBUG`, мы не задавали явно базовую конфигурацию логирования, а по умолчанию она, как вы помните, как раз `WARNING`.

Также вы, возможно, отметили, что вывод лога содержит только само сообщение и больше никакой другой информации. Это можно легко исправить, добавив форматтер для логгера, о чем поговорим в следующем шаге.

**Примечание 1.** Логгер с определенным именем в проекте может быть только один, поэтому, если вы в нескольких модулях создадите логгеры с одинаковым именем, то они будут ссылаться на один и тот же логгер.

**Примечание 2.** Во время создания записи лога внутри логгера создается экземпляр класса `LogRecord`, который хранит в себе всю необходимую информацию, связанную с вызовом лога (время, имя модуля, где был вызван лог, уровень лога и т.п.)

## Форматтеры

Не смотря на то, что можно настроить форматирование с помощью f-строк, так делать не стоит из-за того, что условно это ресурсозатратная операция, которая будет выполняться в любом случае, даже если уровень логирования подразумевает то, что вы логи никуда выводить не будете. Лучше использовать специальный синтаксис, предусмотренный библиотекой `logging`. Плюсом такого подхода будет еще и его универсальность, потому что f-строки появились в Python только с версии 3.6 и, если ваш проект тянет какие-то легаси-части (наследие устаревших версий библиотек и кодовой базы вообще), можно столкнуться с тем, что логирование не будет работать корректно или вообще поломает ваш сервис.

Полный и подробный разбор синтаксиса есть [здесь](https://docs.python.org/3/library/logging.html#formatter-objects).

- `%(asctime)s` - время создания лога в виде, понятном человеку. По умолчанию выглядит так - **2023-12-31 11:29:31,689**
- `%(filename)s` - имя модуля, в котором сработал вызов лога
- `%(funcName)s` - имя функции, в которой произошел вызов лога
- `%(levelname)s` - уровень, на котором был вызван данный лог (`DEBUG`, `INFO` и т.п.)
- `%(lineno)d` - номер строки кода, на которой произошел вызов лога
- `%(name)s` - имя логгера
- `%(message)s` - сообщение, которое должно быть выведено вместе с логом

Комбинируя эти объекты форматирования, можно гибко настраивать то как будут выглядеть ваши логи. Мы в курсе будем использовать вот такой вид:

```python
format='[%(asctime)s] #%(levelname)-8s %(filename)s:'
       '%(lineno)d - %(name)s - %(message)s'
```

И выглядеть логи, форматированные таким образом, будут так:

```no-highlight
[2023-12-29 22:56:02,062] #INFO     dispatcher.py:172 - aiogram.event - Update id=563099722 is handled. Duration 272 ms by bot id=6341710373
[2023-12-29 22:56:08,331] #DEBUG    intent_middleware.py:67 - aiogram_dialog.context.intent_middleware - Loading context for intent: `pCh8w8`, stack: ``, user: `173901673`, chat: `173901673`
[2023-12-29 22:56:08,332] #DEBUG    dialog.py:121 - aiogram_dialog.dialog - Dialog render (Dialog 'FSMMainMenu')
```

То есть сначала идет дата и время создания лога в квадратных скобках - `[%(asctime)s]`, затем через пробел идет, начинающийся с символа `#`, уровень логирования `#%(levelname)-8s`. Причем под сам уровень логирования выделяется ровно 8 символов, а если длина строки, обозначающей уровень, меньше 8, то справа от нее добавляются пробелы - `-8s`. После уровня лога идет имя модуля, в котором сработал лог, а после двоеточия номер строки в коде с вызовом лога - `%(filename)s:%(lineno)d`. Затем идет имя логгера, которое обычно совпадает с полным путем до модуля (начиная от точки входа в проект), в котором был вызван данный лог - `%(name)s`. И в самом конце, собственно, само сообщение лога - `%(message)s`.

Показанный способ форматирования, хоть и до сих пор популярен (вы будете встречать такой вид во многих python-проектах), считается все же устаревшим и симпатичнее выглядит форматирование с помощью фигурных скобок. Оно похоже на f-строки, но, по сути, ими не является и работает эффективнее. Давайте перепишем шаблон для форматирования с использованием фигурных скобок:

```python
format='[{asctime}] #{levelname:8} {filename}:'
       '{lineno} - {name} - {message}'
```

Тут могут возникнуть два основных вопроса. Во-первых, где указать этот параметр `format`? А во-вторых, как Python должен понять в каком именно формате ему передан шаблон форматирования?

Самый простой способ - указать форматирование один раз при базовой конфигурации логирования, например, в точке входа в проект:

```python
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='[%(asctime)s] #%(levelname)-8s %(filename)s:'
           '%(lineno)d - %(name)s - %(message)s'
)

logger = logging.getLogger(__name__)

logger.debug('Лог уровня DEBUG')
```

Результат работы кода:

```no-highlight
[2024-01-02 16:42:22,074] #DEBUG    test_5.py:11 - __main__ - Лог уровня DEBUG
```

Но если подставить в параметр `format` второй способ форматирования (через фигурные скобки), то, увы, ничего не выйдет:

```python
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='[{asctime}] #{levelname:8} {filename}:'
           '{lineno} - {name} - {message}'
)

logger = logging.getLogger(__name__)

logger.debug('Лог уровня DEBUG')
```

Выполнение такого кода приведет к ошибке:

```no-highlight
raise ValueError("Invalid format '%s' for '%s' style" % (self._fmt, self.default_format[0]))
ValueError: Invalid format '[{asctime}] #{levelname:8} {filename}:{lineno} - {name} - {message}' for '%' style
```

Чтобы ее избежать и воспользоваться возможностью форматирования через фигурные скобки, при настройке форматирования нужно еще явно задать значение параметра `style`. По умолчанию в качестве значения этого параметра стоит `'%'`, поэтому и форматирование в первом случае работает, как ожидается. А во втором нужно явно указать `style='{'` и тогда тоже все будет работать:

```python
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='[{asctime}] #{levelname:8} {filename}:'
           '{lineno} - {name} - {message}',
    style='{'
)

logger = logging.getLogger(__name__)

logger.debug('Лог уровня DEBUG')
```

Результат:

```no-highlight
[2024-01-02 16:51:30,084] #DEBUG    test_5.py:12 - __main__ - Лог уровня DEBUG
```

Решайте каким стилем форматирования будете пользоваться сами, я пока предпочитаю `'%'`, хотя и иногда задумываюсь уйти от старых привычек.

Хорошо, красиво форматировать вывод логов мы, вроде, научились. Но пока, через определение базовой конфигурации в `basicConfig`, у нас единый формат для всех логов. А что если мы хотим разные форматы для разных случаев? Где та самая гибкость, о которой я постоянно говорю в этом уроке? И она, разумеется, есть. Вы легко можете определить разные способы форматирования в вашем проекте и легко подключать их в нужных вам местах. За это отвечают форматтеры. Специальные объекты класса `Formatter`, в которых вы и можете хранить настройки форматирования для разных случаев. 

В общем случае, форматтеры можно создавать так:

```python
import logging

format_1 = '#%(levelname)-8s [%(asctime)s] - %(filename)s:'\
           '%(lineno)d - %(name)s - %(message)s'
format_2 = '[{asctime}] #{levelname:8} {filename}:'\
           '{lineno} - {name} - {message}'

formatter_1 = logging.Formatter(fmt=format_1)
formatter_2 = logging.Formatter(
    fmt=format_2,
    style='{'
)
```

- `%(asctime)s` - время создания лога в виде, понятном человеку. По умолчанию выглядит так - **2023-12-31 11:29:31,689**
- `%(filename)s` - имя модуля, в котором сработал вызов лога
- `%(funcName)s` - имя функции, в которой произошел вызов лога
- `%(levelname)s` - уровень, на котором был вызван данный лог (`DEBUG`, `INFO` и т.п.)
- `%(lineno)d` - номер строки кода, на которой произошел вызов лога
- `%(name)s` - имя логгера
- `%(message)s` - сообщение, которое должно быть выведено вместе с логом

Комбинируя эти объекты форматирования, можно гибко настраивать то как будут выглядеть ваши логи. Мы в курсе будем использовать вот такой вид:

```python
format='[%(asctime)s] #%(levelname)-8s %(filename)s:'
       '%(lineno)d - %(name)s - %(message)s'
```

И выглядеть логи, форматированные таким образом, будут так:

```no-highlight
[2023-12-29 22:56:02,062] #INFO     dispatcher.py:172 - aiogram.event - Update id=563099722 is handled. Duration 272 ms by bot id=6341710373
[2023-12-29 22:56:08,331] #DEBUG    intent_middleware.py:67 - aiogram_dialog.context.intent_middleware - Loading context for intent: `pCh8w8`, stack: ``, user: `173901673`, chat: `173901673`
[2023-12-29 22:56:08,332] #DEBUG    dialog.py:121 - aiogram_dialog.dialog - Dialog render (Dialog 'FSMMainMenu')
```

То есть сначала идет дата и время создания лога в квадратных скобках - `[%(asctime)s]`, затем через пробел идет, начинающийся с символа `#`, уровень логирования `#%(levelname)-8s`. Причем под сам уровень логирования выделяется ровно 8 символов, а если длина строки, обозначающей уровень, меньше 8, то справа от нее добавляются пробелы - `-8s`. После уровня лога идет имя модуля, в котором сработал лог, а после двоеточия номер строки в коде с вызовом лога - `%(filename)s:%(lineno)d`. Затем идет имя логгера, которое обычно совпадает с полным путем до модуля (начиная от точки входа в проект), в котором был вызван данный лог - `%(name)s`. И в самом конце, собственно, само сообщение лога - `%(message)s`.

Показанный способ форматирования, хоть и до сих пор популярен (вы будете встречать такой вид во многих python-проектах), считается все же устаревшим и симпатичнее выглядит форматирование с помощью фигурных скобок. Оно похоже на f-строки, но, по сути, ими не является и работает эффективнее. Давайте перепишем шаблон для форматирования с использованием фигурных скобок:

```python
format='[{asctime}] #{levelname:8} {filename}:'
       '{lineno} - {name} - {message}'
```

Тут могут возникнуть два основных вопроса. Во-первых, где указать этот параметр `format`? А во-вторых, как Python должен понять в каком именно формате ему передан шаблон форматирования?

Самый простой способ - указать форматирование один раз при базовой конфигурации логирования, например, в точке входа в проект:

```python
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='[%(asctime)s] #%(levelname)-8s %(filename)s:'
           '%(lineno)d - %(name)s - %(message)s'
)

logger = logging.getLogger(__name__)

logger.debug('Лог уровня DEBUG')
```

Результат работы кода:

```no-highlight
[2024-01-02 16:42:22,074] #DEBUG    test_5.py:11 - __main__ - Лог уровня DEBUG
```

Но если подставить в параметр `format` второй способ форматирования (через фигурные скобки), то, увы, ничего не выйдет:

```python
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='[{asctime}] #{levelname:8} {filename}:'
           '{lineno} - {name} - {message}'
)

logger = logging.getLogger(__name__)

logger.debug('Лог уровня DEBUG')
```

Выполнение такого кода приведет к ошибке:

```no-highlight
raise ValueError("Invalid format '%s' for '%s' style" % (self._fmt, self.default_format[0]))
ValueError: Invalid format '[{asctime}] #{levelname:8} {filename}:{lineno} - {name} - {message}' for '%' style
```

Чтобы ее избежать и воспользоваться возможностью форматирования через фигурные скобки, при настройке форматирования нужно еще явно задать значение параметра `style`. По умолчанию в качестве значения этого параметра стоит `'%'`, поэтому и форматирование в первом случае работает, как ожидается. А во втором нужно явно указать `style='{'` и тогда тоже все будет работать:

```python
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='[{asctime}] #{levelname:8} {filename}:'
           '{lineno} - {name} - {message}',
    style='{'
)

logger = logging.getLogger(__name__)

logger.debug('Лог уровня DEBUG')
```

Результат:

```no-highlight
[2024-01-02 16:51:30,084] #DEBUG    test_5.py:12 - __main__ - Лог уровня DEBUG
```

Решайте каким стилем форматирования будете пользоваться сами, я пока предпочитаю `'%'`, хотя и иногда задумываюсь уйти от старых привычек.

Хорошо, красиво форматировать вывод логов мы, вроде, научились. Но пока, через определение базовой конфигурации в `basicConfig`, у нас единый формат для всех логов. А что если мы хотим разные форматы для разных случаев? Где та самая гибкость, о которой я постоянно говорю в этом уроке? И она, разумеется, есть. Вы легко можете определить разные способы форматирования в вашем проекте и легко подключать их в нужных вам местах. За это отвечают форматтеры. Специальные объекты класса `Formatter`, в которых вы и можете хранить настройки форматирования для разных случаев. 

В общем случае, форматтеры можно создавать так:

```python
import logging

format_1 = '#%(levelname)-8s [%(asctime)s] - %(filename)s:'\
           '%(lineno)d - %(name)s - %(message)s'
format_2 = '[{asctime}] #{levelname:8} {filename}:'\
           '{lineno} - {name} - {message}'

formatter_1 = logging.Formatter(fmt=format_1)
formatter_2 = logging.Formatter(
    fmt=format_2,
    style='{'
)
```

## Хэндлеры

За каждым логгером может быть закреплено от нуля до любого количества хэндлеров. Хэндлеры логгера можно посмотреть, если обратиться к атрибуту `handlers`:

```python
import logging

logger = logging.getLogger(__name__)

print(logger.handlers)
```

В данном случае, список будет пустым:

```no-highlight
[]
```

В библиотеке `logging` есть как стандартные классы для создания хэндлеров, так и возможность создавать кастомные хэндлеры для отправки логов куда угодно. Например класс `StreamHandler` позволяет определить вывод логов в `stdout` или `stderr` (по умолчанию как раз `stderr`), а класс `FileHandler` позволяет определить вывод логов в файл. А чтобы создать свой собственный хэндлер - нужно отнаследоваться от класса `Handler` и переопределить некоторые его методы.

**Пример 1.** Хэндлеры для вывода логов в `stderr` и `stdout`.

```python
import logging
import sys

logger = logging.getLogger(__name__)

stderr_handler = logging.StreamHandler()
stdout_handler = logging.StreamHandler(sys.stdout)

logger.addHandler(stdout_handler)
logger.addHandler(stderr_handler)

print(logger.handlers)

logger.warning('Это лог с предупреждением!')
```

Результат работы кода будет следующим:

```bash
[<StreamHandler <stdout> (NOTSET)>, <StreamHandler <stderr> (NOTSET)>]
Это лог с предупреждением!
Это лог с предупреждением!
```

Во-первых, теперь у логгера в списке есть 2 хэндлера, а во-вторых, теперь в консоли мы видим сообщение лога два раза, потому что в консоли отображается сразу и `stderr` и `stdout` потоки, в третьих, уровень хэндлеров `NOTSET`, а значит, они будут обрабатывать логи любого уровня. Если задать хэндлерам какой-то другой уровень, например, `INFO`, то обрабатывать они будут только логи, начиная с этого уровня (`INFO`, `WARNING`, `ERROR` и `CRITICAL`).

**Пример 2.** Хэндлеры для вывода логов в `stderr` и `stdout` с разным форматированием.

Чтобы добавить форматтер к хэндлеру - нужно воспользоваться методом `setFormatter`.

```python
import logging
import sys

# Определяем первый вид форматирования
format_1 = '#%(levelname)-8s [%(asctime)s] - %(filename)s:'\
           '%(lineno)d - %(name)s - %(message)s'
# Определяем второй вид форматирования
format_2 = '[{asctime}] #{levelname:8} {filename}:'\
           '{lineno} - {name} - {message}'

# Инициализируем первый форматтер
formatter_1 = logging.Formatter(fmt=format_1)
# Инициализируем второй форматтер
formatter_2 = logging.Formatter(
    fmt=format_2,
    style='{'
)

# Создаем логгер
logger = logging.getLogger(__name__)

# Инициализируем хэндлер, который будет перенаправлять логи в stderr
stderr_handler = logging.StreamHandler()
# Инициализируем хэндлер, который будет перенаправлять логи в stdout
stdout_handler = logging.StreamHandler(sys.stdout)

# Устанавливаем форматтеры для хэндлеров
stderr_handler.setFormatter(formatter_1)
stdout_handler.setFormatter(formatter_2)

# Добавляем хэндлеры логгеру
logger.addHandler(stdout_handler)
logger.addHandler(stderr_handler)

# Создаем лог
logger.warning('Это лог с предупреждением!')
```

Если выполнить этот код, то в консоли теперь можно увидеть форматированный нашими форматтерами вывод логов:

```no-highlight
[2024-01-02 18:18:27,987] #WARNING  test_5.py:34 - __main__ - Это лог с предупреждением!
#WARNING  [2024-01-02 18:18:27,987] - test_5.py:34 - __main__ - Это лог с предупреждением!
```

**Пример 3.** Хэндлер для записи логов в файл.

```python
import logging

logger = logging.getLogger(__name__)

file_handler = logging.FileHandler('logs.log')

logger.addHandler(file_handler)

print(logger.handlers)

logger.warning('Это лог с предупреждением!')
```

Выполнив этот код, получаем результат в консоли:

```bash
[<FileHandler /<здесь_полный_путь_до_файла_с_логами>/logs.log (NOTSET)>]
```

А в файле **logs.log**:

```no-highlight
Это лог с предупреждением!
```

По умолчанию, логи будут записываться в файл путем добавления каждой новой записи с новой строки, но этим поведением можно управлять. Например, можно перезаписывать файл с логами каждый раз, при запуске кода. Для этого классу `FileHandler` нужно передать аргумент `mode='w'` (по умолчанию `mode='a'`, от "append" - добавить, поэтому явно мы его не указывали).

Как и в предыдущем примере к хэндлеру можно добавить свой форматтер, чтобы придать ему более информативный вид.

В библиотеке `logging` уже реализовано довольно много полезных хэндлеров для управления логами: логи можно отправлять по электронной почте `SMTPHandler`, "из коробки" можно создать ротацию файлов с логами, при достижении ими определенного объема или по времени - `RotatingFileHandler` и `TimedRotatingFileHandler`, можно отправлять логи по HTTP - `HTTPHandler` и так далее. Список других полезных готовых хэндлеров можно посмотреть [здесь](https://docs.python.org/3/howto/logging.html#useful-handlers).

## Фильтры


**Пример 1.** Фильтр, который будет передавать в хэндлеры только логи уровня `ERROR`, в которых есть слово "важно", написанное в любом регистре.

```python
import logging


# Определяем свой фильтр, наследуюясь от класса Filter библиотеки logging
class ErrorLogFilter(logging.Filter):
    # Переопределяем метод filter, который принимает `self` и `record`
    # Переменная рекорд будет ссылаться на объект класса LogRecord
    def filter(self, record):
        return record.levelname == 'ERROR' and 'важно' in record.msg.lower()


# Инициализируем логгер
logger = logging.getLogger(__name__)

# Создаем хэндлер, который будет направлять логи в stderr
stderr_handler = logging.StreamHandler()

# Подключаем фильтр к хэндлеру
stderr_handler.addFilter(ErrorLogFilter())

# Подключаем хэндлер к логгеру
logger.addHandler(stderr_handler)

logger.warning('Важно! Это лог с предупреждением!')
logger.error('Важно! Это лог с ошибкой!')
logger.info('Важно! Это лог с уровня INFO!')
logger.error('Это лог с ошибкой!')
```

Результатом работы кода будет:

```no-highlight
Важно! Это лог с ошибкой!
```

То есть видно, что это сообщение лога с уровня `ERROR`, выведенное в `stderr`, чего мы и хотели добиться с помощью фильтра.

**Пример 2.** Фильтр, который будет передавать в хэндлеры логи, только если значение счетчика в цикле `for` будет четным числом.

```python
import logging


# Определяем свой фильтр, наследуюясь от класса Filter библиотеки logging
class EvenLogFilter(logging.Filter):
    def filter(self, record):
        return not record.i % 2


# Инициализируем логгер
logger = logging.getLogger(__name__)

# Создаем хэндлер, который будет направлять логи в stderr
stderr_handler = logging.StreamHandler()

# Подключаем фильтр к хэндлеру
stderr_handler.addFilter(EvenLogFilter())

# Подключаем хэндлер к логгеру
logger.addHandler(stderr_handler)

for i in range(1, 5):
    logger.warning('Важно! Это лог с предупреждением! %d', i, extra={'i': i})
```

Результат работы кода:

```no-highlight
Важно! Это лог с предупреждением! 2
Важно! Это лог с предупреждением! 4
```

То есть с помощью параметра `extra` можно в словаре передавать какие-то дополнительные данные, которые затем будут доступны у экземпляра класса `LogRecord` в фильтре. Ключи из словаря становятся атрибутами объекта типа `LogRecord`, по которым доступны значения по этим ключам в словаре `extra`.

## Логирование исключений

Немного особняком стоит метод `exception` у логгера, поэтому на нем нужно заострить внимание отдельно. Он служит для того, чтобы выводить логи уровня `ERROR`, но с полным трейсбэком ошибки. Применять его целесообразно внутри блоков `try`/`except`. Как всегда обратимся к примеру. Допустим, мы хотим обернуть в `try`/`except` код, в котором потенциально может возникнуть исключение. Тогда код выполнится даже при возбуждении исключения, но если мы такое исключение не залогируем, то мы даже можем не узнать, что оно было. Продемонстрирую на стандартном примере с делением на ноль.

**Пример 1.** Деление на ноль без блока `try`/`except`.

```python
print(4 / 2)
print(2 / 0)
```

Выполнение такого кода приводит к возбуждению исключения `ZeroDivisionError`:

```no-highlight
2.0
Traceback (most recent call last):
  File "/<здесь_путь_к_файлу>/test_5.py", line 4, in <module>
    print(2 / 0)
          ~~^~~
ZeroDivisionError: division by zero
```

А теперь обернем данную конструкцию в блок `try`/`except` и в случае возникновения исключения `ZeroDivisionError` ничего не будем делать.

**Пример 2.** Деление на ноль внутри блока `try`/`except`.

```python
try:
    print(4 / 2)
    print(2 / 0)
except ZeroDivisionError:
    pass
```

Код выполнится без ошибок:

```no-highlight
2.0
```

То есть если мы не будем логировать исключение явно, то как-будто его и не было. Ну, самое простое, что может прийти на ум - это добавить лог внутри блока `except`:

**Пример 3.** Деление на ноль внутри блока `try`/`except` с логированием.

```python
import logging

logger = logging.getLogger(__name__)

try:
    print(4 / 2)
    print(2 / 0)
except ZeroDivisionError:
    logger.error('Тут было исключение')
```

Результат:

```no-highlight
2.0
Тут было исключение
```

Как можно заметить лог был выведен, но никакой информации об исключении, никакого трейсбэка нет.

Добавить трейсбэк ошибки в лог можно двумя основными способами - через указание дополнительного аргумента в методе логгера `error` (впрочем, в методах `debug`, `info`, `warning` и `critical` такой аргумент также можно добавить) и через использование специального метода `exception`. Покажу оба способа на примерах.

**Пример 4.** Лог вместе с трейсбэком ошибки через передачу методу логгера аргумента `exc_info=True`.

```python
import logging

logger = logging.getLogger(__name__)

try:
    print(4 / 2)
    print(2 / 0)
except ZeroDivisionError:
    logger.error('Тут было исключение', exc_info=True)
```

И теперь информация об исключении также записана в лог:

```no-highlight
2.0
Тут было исключение
Traceback (most recent call last):
  File "/<тут_путь_к_файлу>/test_5.py", line 40, in <module>
    print(2 / 0)
          ~~^~~
ZeroDivisionError: division by zero
```

Точно такого же результата можно добиться, если вызвать метод `exception` у логгера, вместо метода `error`. Тогда уже не надо передавать дополнительный аргумент `exc_info=True`.

**Пример 5.** Лог вместе с трейсбэком ошибки через вызов метода `exception` у логгера.

```python
import logging

logger = logging.getLogger(__name__)

try:
    print(4 / 2)
    print(2 / 0)
except ZeroDivisionError:
    logger.exception('Тут было исключение')
```

И результат такой же:

```no-highlight
2.0
Тут было исключение
Traceback (most recent call last):
  File "/<тут_путь_к_файлу>/test_5.py", line 40, in <module>
    print(2 / 0)
          ~~^~~
ZeroDivisionError: division by zero
```

## Конфигурирование логирования

