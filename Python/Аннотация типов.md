## Аннотация типов
1. [Типизированный Python](https://youtu.be/dKxiHlZvULQ) - почти трехчасовой YouTube-ролик с подробным объяснением и множеством примеров.
2. [Книга](https://to.digital/typed-python/) по мотивам ролика для тех, кому удобнее читать, чем смотреть.

Синтаксис аннотаций для переменных следующий:

```no-highlight
<имя_переменной>: <тип_переменной> = <значение_переменной>
```

Или без значения переменной:

```no-highlight
<имя_переменной>: <тип_переменной>:
```

Синтаксис аннотаций для функций (методов):

```python
def <имя_функции>(<arg_1>: <тип>, <arg_2>: <тип> = <значение>) -> <тип_результата>:
    <тело функции>
```

Причем, если нужно указать больше одного типа, например, функция может принимать и целые, и вещественные числа, используют символ `|`, обозначающий "или".

**Пример 1.** Функция `some_function` принимает либо целое, либо вещественное число, а возвращает `None`.

```python
def some_function(number: int | float) -> None:
    pass
```

**Пример 2.** Функция `another_some_function` принимает либо целое, либо вещественное, либо комплексное число со значением по умолчанию, равным `0`. Возращает `None`.

```python
def another_some_function(number: int | float | complex = 0) -> None:
    pass
```

Коллекции, типа, `list`, `dict`, `tuple`, `set` и т.п., также в квадратных скобках позволяют указывать типы, входящих в них объектов.

**Пример 3.** 

```python
lst_1: list[int]                # Все элементы списка lst_1 типа int
tpl_2: tuple[bool]              # Все элементы кортежа tpl_2 типа bool
tpl_3: tuple[int, bool, float]  # Кортеж tpl_3 состоит из трех элементов
                                # Первый типа int, второй типа bool, а третий типа float
set_4: set[int | float]         # Элементы множества set_4 либо int, либо float типов
```

**Пример 4.** Функция `get_tuple` принимает список, в котором могут быть вещественные числа и/или булевы значения, а возвращает кортеж целых чисел.

```python
def get_tuple(lst: list[float | bool]) -> tuple[int]:
    return tuple(int(num) for num in lst)
```

**Пример 5.** Функция `do_something` принимает словарь, ключами в котором являются целые числа, а значениями либо строки, либо булевы значения. Возвращает `None`.

```python
def do_something(arg: dict[int, str | bool]) -> None:
    pass
```

## Типы из модуля typing

Помимо стандартных встроенных типов, для аннотаций можно использовать типы из модуля `typing`. Там много всего - можно подробно изучить в [документации к модулю](https://docs.python.org/3/library/typing.html). Разберем некоторые интересные:

- Any
- Optional
- Union
- Literal

### Тип Any (использовать, по-возможности, никогда :) )

Бывает так, что указать тип не представляется возможным, потому что точно неизвестно какие данные придут. Тогда используют тип `Any` из модуля `typing`. 

```python
from typing import Any


def func(arg: Any) -> None:
    pass
```

Использовать часто этот тип не рекомендуется, потому что единственное, что он нам говорит о функции, что она может принимать данные любых типов. В принципе, если мы не аннотируем ее, то тоже будем думать, что она может принимать данные любых типов. Не очень информативно. Лучше все-таки разобраться, что там за данные приходят и добавить более осмысленную аннотацию.

### Тип Optional

Данный тип подразумевает, что данные могут быть либо какого-то конкретного типа, либо `None`.

```python
from typing import Optional


var_1: Optional[int]
```

### Тип Union

Как понятно из названия типа - это объединение разных типов. По сути - это другой способ записать, что переменная может быть либо одного, либо другого типа, как мы это делали с помощью символа `|`.

Код:

```python
from typing import Union


var_1: Union[int, float]
var_2: Union[list, tuple, set]
```

эквивалентен коду:

```python
var_1: int | float
var_2: list | tuple | set
```

### Тип Literal

Используется тогда, когда ожидаются очень конкретные значения (`Literal` - от английского "literally", то есть "буквально"). Например, в качестве ключей словаря могут быть только строки `'name'`, `'second_name'` и `'username'`. Тогда можно записать:

```python
from typing import Literal


user : dict[Literal['name'] | Literal['second_name'] | Literal['username'], str]
```

Во-первых, IDE сможет подсказать какие ключи в таком словаре доступны, а во-вторых, анализатор кода будет ругаться, если мы попробуем в такой словарь поместить какой-то другой ключ.

![](https://ucarecdn.com/380fc7b4-024f-413a-b668-01dd3a21e65d/-/preview/-/enhance/75/)

![](https://ucarecdn.com/d8af43bd-fcc3-4dcf-b39e-7245b4b86ad8/-/preview/-/enhance/75/)

Помимо обозначенных типов, в модуле `typing` их еще много разных, буквально, на все случаи жизни. А если и их вам не хватает - никто не мешает создавать свои классы. Чем мы и займемся в следующем шаге.